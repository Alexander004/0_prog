---
title: "Untitled"
output: html_document
date: "2023-04-15"
---

***Алгоритм Кристофидеса***
Решаем задачу с его помощью

Алгоритм:

1. Создаём минимальное остовное дерево T графа G.
2. Пусть O будет набором вершин с нечётными степенями в T. Согласно лемме о рукопожатиях, O имеет чётное число вершин.
3. Находим совершенное паросочетание M минимального веса в порождённом подграфе, заданным вершинами из O.
4. Комбинируем рёбра M и T с образованием связного мультиграфа H, в котором каждая вершина имеет чётную степень.
5. Образуем эйлеров цикл в H.
6. Преобразуем цикл, найденный на предыдущем шаге, в гамильтонов цикл путём пропуска повторяющихся вершин (сокращение).

```{r}
#install.packages("igraph")
library(igraph)

# Define the adjacency matrix for the graph
adj_mat <- matrix(c(0, 7, 4, 0, 0, 0, 0,
                    0, 0, 0, 2, 0, 0, 0,
                    0, 0, 0, 1, 0, 3, 0,
                    0, 0, 0, 0, 1, 0, 0,
                    0, 0, 0, 0, 0, 8, 0,
                    0, 0, 0, 0, 0, 0, 2,
                    0, 0, 0, 0, 0, 0, 0), nrow = 7, byrow = TRUE)
# Define the vertex labels for the graph
vertex_labels <- c("A", "B", "C", "D", "E", "F", "G")

# Set the row and column names for the matrices
rownames(adj_mat) <- vertex_labels
colnames(adj_mat) <- vertex_labels

g <- graph_from_adjacency_matrix(adj_mat, "undirected", weighted = TRUE)
plot(g, edge.label = E(g)$weight)
```
```{r}
g[]
```
***1*** (ВОЗМОЖНО НЕ НУЖЕН)
Создание минимального остовного дерева

Возможный способ: Алгоритм обратного удаления

Смысл:
1. сортируем веса ребер
2. выбираем самое большое ребро. приведет ли его удаление к несвязанности графа? если нет - удаляем

```{r}
#g_mst <- mst(g)
#plot(g_mst, edge.label = E(g)$weight)
```


***2***
Находим нечетные вершины

Сначала нам нужно выяснить какие вершины с нечетными степенями (степень - количество примыкающих к вершине ребер)
```{r}
ad_new <- as_adjacency_matrix(g, attr="weight")
ad_new <- as.matrix(ad_new)
ad_new
```


```{r}
degrees <- rowSums(ad_new != 0)
degrees
```
```{r}
odds <- which(degrees %% 2 == 1)
odds
```
***3***
Составляем из нечетных вершин подграф

```{r}
adj_mat[odds, odds]
```


```{r}
subgraph <- graph_from_adjacency_matrix(adj_mat[odds, odds], "undirected", weighted = TRUE)
plot(subgraph, edge.label = E(subgraph)$weight)
```
***4***
Находим совершенного сочетания минимального веса

* Паросочетанием называется множество попарно несмежных ребер (не имеющих общих вершин). 
* Паросочетание называется совершенным, если оно покрывает все вершины. 
* Весом паросочетания называется суммарный вес входящих в него ребер.

Цитата из решения:
"Существуют эффективные алгоритмы поиска совершенного сочетания минимального веса. Однако они очень трудны. Поэтому при малом количестве вершин в графе можно воспользоваться перебором всех возможных совершенных паросочетаний."

В нашем случае совершенное паросочетание - G--F и C--D

```{r}
E(subgraph)$type = c(1,0,1)
E(subgraph)$color[E(subgraph)$type == 1] <- "red"
E(subgraph)$color[E(subgraph)$type == 0] <- "gray"
plot(subgraph, edge.width = 6,edge.label = E(subgraph)$weight)
```
***5***
Комбинируем полученные рёбра с исходным графом, создаем связный мультиграф, в котором каждая вершина имеет чётную степень

```{r}
task <- graph( edges=c("G","F", "F","C", "C","A", "A","B", "B","D", "D","C", "C","D", "D","E", "E","F", "F","G"), directed=F ) 
plot(task)
```


***6***
Образуем эйлеров цикл

*Согласно теореме, доказанной Эйлером, эйлеров цикл существует тогда и только тогда, когда граф связный или будет являться связным, если удалить из него все изолированные вершины, и в нём отсутствуют вершины нечётной степени.
```{r}
a <- make_graph( ~ A-B-C-A )
plot(a)
```


```{r}
eulerian_cycle(a)
```
```{r}
task <- graph( edges=c("G","F", "F","C", "C","A", "A","B", "B","D", "D","C", "C","D", "D","E", "E","F", "F","G"), directed=F ) 
plot(task)
```
```{r}
eulerian_cycle(task)
```
***Practice***

Давайте сделаем тоже самое с вашим графом
